{
    "URL": "https://github.com/verilator/verilator/issues/4138",
    "Summary": "Support inside expressions with strings and doubles",
    "Description": "This issue can manifest in several ways. For example\ntask foo(string s);\n  if (s inside {\"RW\", \"WO\"})\n    $display(\"string: %s\", s);\nendtask\n\nmodule t();\n  foo(\"ABC\");\nendmodule\nwill compile, but the simulation output will be incorrect:\nstring: ABC\n\nHowever, when the task is moved into a class, like so:\nclass Bar;\n  task foo(string s);\n    if (s inside {\"RW\", \"WO\"})\n      $display(\"string: %s\", s);\n  endtask\nendclass\nthis will no longer compile, leaving a lengthy set of errors, starting with:\nVt_inside_nonint___024unit__03a__03aBar__Vclpkg__DepSet_hdd08c3fc__0.cpp:13:33: error: no match for ‘operator==’ (operand types are ‘long long unsigned int’ and ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’})\n   13 |     if (VL_UNLIKELY(((0x5257ULL == s) | (0x574fULL\n      |                       ~~~~~~~~~ ^~ ~\n      |                       |            |\n      |                       |            std::string {aka std::__cxx11::basic_string<char>}\n      |                       long long unsigned int\nIt's even more straightforward with reals:\ntask foo(real d);\n  if (d inside {0.0, 1.0})\n    $display(\"string: %f\", d);\nendtask\n\nresults in:\n%Warning-REALCVT: test_regress/t/t_inside_nonint.v:2:7: Implicit conversion of real to integer\n-node: VARREF 0x55e39fb81f90 {d2ah} @dt=0x55e39fba2880@(d)  d pkg=0x55e39fba37c0 [RV] <- VAR 0x55e39fba2950 {d1ap} @dt=0x55e39fba2880@(d)  d INPUT [FUNC] PORT\n    2 |   if (d inside {0.0, 1.0})\n      |       ^\n                  ... For warning description see https://verilator.org/warn/REALCVT?v=5.009\n                  ... Use \"/* verilator lint_off REALCVT */\" and lint_on around source to disable this message.\n\n\nAfter looking into the code, I found out that the logic for inside statement assumes that it is dealing with logic values. Interestingly enough, this doesn't always result in any reported error. The reason seems to be that string literals are treated as logic vectors which eventually get casted if there's a need to do so. I guess that in the first example, the s string got constified before it gets compared with the literals which ended up removing the type mismatch. It is puzzling however, that the expression evaluated to 1'b1, so I 'm not sure about this explanation.\n\nVerilator version: 84a4693\nOS: Gentoo Linux (x86_64)"
}