{
    "URL": "https://github.com/verilator/verilator/issues/4536",
    "Summary": "Shift when using streaming operator on 32 bit signal",
    "Description": "The problem\nUsing the attached minimal code, and the command verilator --binary --trace-fst mwe.sv && ./obj_dir/Vmwe, the simulation will fail with the message MISMATCH. The expected result is a complete successful simulation ( MATCH message and end on $finish).\nThe MWE loads a buffer 4-bits by 4-bits and output the result using a streaming operator {<<4{buffer}}. The input data is, in hexadecimal C,A,F,E,F,A,D,E and so, the expected output result is 0xEDAFEFAC.  However, with what I believe is a very specific setup, demonstrated by the MWE, the output is 0x0EDAFEFA.\nThe output value o behave as if it was o = expected >> 4;\nImportant to note:\n\n--trace instead of --trace-fst will FAIL in the same fashion.\nOmitting --trace will PASS the test (output is MATCH, and $display'ed value is correct).\nChanging the buffer size for anything that is not 32bits (Checked with 8, 16, 28, 36 and 64 bits) will PASS the test.\nUsing a simple assign buffer_lsbf = {<<4{buffer}}; instead of the combinatorial process used, will PASS.\nUsing directly case (2'b11) instead of case (nlanes) will PASS\nUsing a const logic [1:0] nlanes = 2'b11 instead of the current nlanes definition will still FAIL.\nNot using the logic to shift the buffer and/or the sequential logic for buffer will PASS.\nUsing the same logic with a packing by two ({<<2{...}}) will FAIL but with two leading 0 instead of four (o = expected >> 2).\n\nTestcase\nmodule mwe ();\n\n    localparam int K_DWIDTH = 32;\n\n    logic clk ;\n    logic rstn;\n\n    logic [1:0] nlanes;\n\n    logic [         3:0] i   ;\n    logic [K_DWIDTH-1:0] o   ;\n    logic                lsbf;\n\n    logic [K_DWIDTH-1:0] buffer     ;\n    logic [K_DWIDTH-1:0] buffer_next;\n    logic [K_DWIDTH-1:0] buffer_lsbf;\n\n    assign o = lsbf ? buffer_lsbf : buffer;\n    \n    always_comb begin\n        case (nlanes)\n            2'b11 : begin\n                buffer_lsbf = {<<4{buffer}};\n            end\n            default : begin\n                buffer_lsbf = {<<{buffer}};\n            end\n        endcase\n    end\n\n    always_comb begin\n        buffer_next = {buffer[K_DWIDTH-1-4:0],i[3:0]};\n    end\n\n    always_ff @( posedge clk or negedge rstn ) begin\n        if (~rstn) begin\n            buffer <= 0;\n        end else begin\n            buffer <= buffer_next;\n        end\n    end\n\n    initial begin\n        rstn = 0;\n        clk = 0;\n        #10ns;\n        rstn = 1;\n        #10ns;\n        forever begin\n            clk = ~clk;\n            #5ns;\n        end\n    end\n\n    initial begin\n        $dumpfile(\"dump.fst\");\n        $dumpvars;\n        i = 0;\n        lsbf = 1;\n        nlanes = 2'b11;\n        #15ns;\n        i = 4'hC; #10ns;\n        i = 4'hA; #10ns;\n        i = 4'hF; #10ns;\n        i = 4'hE; #10ns;\n        i = 4'hF; #10ns;\n        i = 4'hA; #10ns;\n        i = 4'hD; #10ns;\n        i = 4'hE; #10ns;\n        $display(\"Data is 0x%h\",o);\n        if(o == 32'hEDAFEFAC) begin\n            $display(\"MATCH\");\n        end else begin\n            $error(\"MISMATCH\");\n        end\n        #10ns;\n        $finish;\n    end\n\nendmodule\nWhat 'verilator --version' are you using?  Did you try it with the git master version?\nThis bug is shown at least with:\n\nv5.014\nv5.016\nmaster ( Verilator 5.017 devel rev v5.014-149-ga3c154dcd )\n\nThe simulation behave as expected on other simulator (Xcelium).\nWhat OS and distribution are you using?\nUbuntu 22.04.3 LTS in WSL 2 for Windows 11 .\nMay we assist you in trying to fix this in Verilator yourself?\nI can try to have a look, but I'm not familiar with Verilator codebase and this seems to be a rather specific issue, so it would probably be faster if you handle it."
}